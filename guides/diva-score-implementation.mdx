# DIVA Score Implementation Guide

This guide provides comprehensive instructions for implementing AWO Platform's proprietary DIVA scoring system with RTSM (Risk Tolerance Scoring Model) integration for intelligent portfolio assignment.

<Info>
DIVA scoring combines Discipline, Income, Velocity, and Assets analysis to create a 0-1000 point financial health score that automatically assigns users to Bronze, Silver, Gold, or Platinum investment portfolios.
</Info>

## Understanding DIVA Scoring

### Core Components

The DIVA scoring system evaluates four key financial health dimensions:

<CardGroup cols={2}>
  <Card title="Discipline (30%)" icon="shield-check">
    **Payment Consistency**: On-time bill payments, loan repayments  
    **Overdraft Avoidance**: Frequency and severity of overdrafts  
    **Savings Regularity**: Consistent savings behavior patterns  
    **Budget Adherence**: Spending within planned categories
  </Card>
  <Card title="Income (25%)" icon="wallet">
    **Stability**: Consistency of income over time  
    **Growth**: Income trajectory and improvement  
    **Diversification**: Multiple income sources  
    **Reliability**: Predictability of income streams
  </Card>
  <Card title="Velocity (25%)" icon="bolt">
    **Cash Flow Timing**: Efficiency of money movement  
    **Transaction Patterns**: Optimal spending timing  
    **Liquidity Management**: Available cash vs obligations  
    **Payment Efficiency**: Speed of financial transactions
  </Card>
  <Card title="Assets (20%)" icon="building">
    **Savings Rate**: Percentage of income saved monthly  
    **Investment Balance**: Diversified investment holdings  
    **Net Worth Growth**: Increasing asset value over time  
    **Debt-to-Asset Ratio**: Healthy debt management
  </Card>
</CardGroup>

### Portfolio Tier Assignment

Based on combined DIVA + RTSM scores:

| Tier | DIVA Score Range | Portfolio Access | Investment Limit | SME Access |
|------|------------------|------------------|------------------|------------|
| Bronze | 0-399 | Money market, T-Bills | R10,000 | None |
| Silver | 400-649 | Index funds, T-Bonds, ETFs | R50,000 | Limited |
| Gold | 650-849 | Diversified ETFs, higher yield | R200,000 | Yes |
| Platinum | 850-1000 | Full access, premium SME | Unlimited | Premium |

## Implementation Architecture

### Database Schema

Set up the required database tables for DIVA scoring:

```sql
-- diva_scores table
CREATE TABLE diva_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    overall_score INTEGER NOT NULL CHECK (overall_score >= 0 AND overall_score <= 1000),
    discipline_score INTEGER NOT NULL CHECK (discipline_score >= 0 AND discipline_score <= 1000),
    income_score INTEGER NOT NULL CHECK (income_score >= 0 AND income_score <= 1000),
    velocity_score INTEGER NOT NULL CHECK (velocity_score >= 0 AND velocity_score <= 1000),
    assets_score INTEGER NOT NULL CHECK (assets_score >= 0 AND assets_score <= 1000),
    portfolio_tier VARCHAR(20) NOT NULL CHECK (portfolio_tier IN ('bronze', 'silver', 'gold', 'platinum')),
    calculation_version VARCHAR(10) NOT NULL DEFAULT 'v1.0',
    data_period_start DATE NOT NULL,
    data_period_end DATE NOT NULL,
    calculated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    next_update_due TIMESTAMP NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'expired', 'recalculating')),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- diva_score_history for tracking changes
CREATE TABLE diva_score_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    diva_score_id UUID NOT NULL REFERENCES diva_scores(id),
    overall_score INTEGER NOT NULL,
    discipline_score INTEGER NOT NULL,
    income_score INTEGER NOT NULL,
    velocity_score INTEGER NOT NULL,
    assets_score INTEGER NOT NULL,
    portfolio_tier VARCHAR(20) NOT NULL,
    tier_change VARCHAR(20), -- 'upgraded', 'downgraded', 'maintained'
    calculated_at TIMESTAMP NOT NULL,
    archived_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- diva_insights for actionable recommendations
CREATE TABLE diva_insights (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    diva_score_id UUID NOT NULL REFERENCES diva_scores(id),
    category VARCHAR(20) NOT NULL CHECK (category IN ('discipline', 'income', 'velocity', 'assets')),
    insight_type VARCHAR(30) NOT NULL, -- 'improvement_opportunity', 'strength', 'warning'
    title VARCHAR(200) NOT NULL,
    description TEXT NOT NULL,
    recommendation TEXT NOT NULL,
    impact_level VARCHAR(10) NOT NULL CHECK (impact_level IN ('low', 'medium', 'high')),
    actionable BOOLEAN NOT NULL DEFAULT true,
    priority INTEGER NOT NULL DEFAULT 50,
    expires_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- rtsm_assessments for Risk Tolerance Scoring
CREATE TABLE rtsm_assessments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    assessment_version VARCHAR(10) NOT NULL DEFAULT 'v1.0',
    overall_risk_score INTEGER NOT NULL CHECK (overall_risk_score >= 0 AND overall_risk_score <= 100),
    risk_profile VARCHAR(20) NOT NULL CHECK (risk_profile IN ('conservative', 'moderate', 'balanced', 'growth', 'aggressive')),
    time_horizon INTEGER NOT NULL, -- months
    risk_capacity_score INTEGER NOT NULL,
    risk_tolerance_score INTEGER NOT NULL,
    investment_experience_score INTEGER NOT NULL,
    recommended_allocation JSONB NOT NULL,
    responses JSONB NOT NULL,
    completed_at TIMESTAMP NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'expired')),
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_diva_scores_user_id ON diva_scores(user_id);
CREATE INDEX idx_diva_scores_calculated_at ON diva_scores(calculated_at DESC);
CREATE INDEX idx_diva_scores_tier ON diva_scores(portfolio_tier);
CREATE INDEX idx_diva_score_history_user_id ON diva_score_history(user_id);
CREATE INDEX idx_rtsm_assessments_user_id ON rtsm_assessments(user_id);
```

### Core Calculation Engine

Implement the DIVA scoring calculation engine:

```typescript
// diva-calculator.ts
import { DatabaseService } from './database-service';
import { BankingService } from './banking-service';

export interface DivaCalculationInput {
  user_id: string;
  analysis_period_months: number; // Default: 12 months
  force_recalculation?: boolean;
}

export interface DivaScoreComponents {
  discipline: number;
  income: number;
  velocity: number;
  assets: number;
}

export interface DivaScoreResult {
  user_id: string;
  overall_score: number;
  components: DivaScoreComponents;
  portfolio_tier: 'bronze' | 'silver' | 'gold' | 'platinum';
  insights: DivaInsight[];
  calculation_metadata: {
    data_period_start: Date;
    data_period_end: Date;
    transactions_analyzed: number;
    accounts_analyzed: number;
    calculation_version: string;
  };
}

export interface DivaInsight {
  category: 'discipline' | 'income' | 'velocity' | 'assets';
  insight_type: 'improvement_opportunity' | 'strength' | 'warning';
  title: string;
  description: string;
  recommendation: string;
  impact_level: 'low' | 'medium' | 'high';
  actionable: boolean;
  priority: number;
}

export class DivaCalculator {
  constructor(
    private db: DatabaseService,
    private bankingService: BankingService
  ) {}

  async calculateDivaScore(input: DivaCalculationInput): Promise<DivaScoreResult> {
    const { user_id, analysis_period_months = 12 } = input;

    // Check if recent calculation exists (unless forced)
    if (!input.force_recalculation) {
      const existingScore = await this.getRecentScore(user_id);
      if (existingScore && this.isScoreRecent(existingScore, 7)) { // 7 days threshold
        return existingScore;
      }
    }

    // Gather financial data
    const endDate = new Date();
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - analysis_period_months);

    const financialData = await this.gatherFinancialData(user_id, startDate, endDate);

    // Calculate component scores
    const components = {
      discipline: await this.calculateDisciplineScore(financialData),
      income: await this.calculateIncomeScore(financialData),
      velocity: await this.calculateVelocityScore(financialData),
      assets: await this.calculateAssetsScore(financialData)
    };

    // Calculate overall score
    const overall_score = Math.round(
      (components.discipline * 0.30) +
      (components.income * 0.25) +
      (components.velocity * 0.25) +
      (components.assets * 0.20)
    );

    // Determine portfolio tier
    const portfolio_tier = this.determinePortfolioTier(overall_score);

    // Generate insights
    const insights = await this.generateInsights(components, financialData);

    const result: DivaScoreResult = {
      user_id,
      overall_score,
      components,
      portfolio_tier,
      insights,
      calculation_metadata: {
        data_period_start: startDate,
        data_period_end: endDate,
        transactions_analyzed: financialData.transactions.length,
        accounts_analyzed: financialData.accounts.length,
        calculation_version: 'v1.0'
      }
    };

    // Save to database
    await this.saveScoreResult(result);

    return result;
  }

  private async calculateDisciplineScore(data: FinancialData): Promise<number> {
    let disciplineScore = 0;
    let maxScore = 1000;

    // Payment punctuality (40% of discipline score)
    const paymentPunctuality = this.analyzePunctuality(data.transactions);
    disciplineScore += paymentPunctuality * 0.40;

    // Overdraft avoidance (25% of discipline score)
    const overdraftScore = this.analyzeOverdraftBehavior(data.transactions);
    disciplineScore += overdraftScore * 0.25;

    // Savings consistency (35% of discipline score)
    const savingsConsistency = this.analyzeSavingsRegularity(data.transactions);
    disciplineScore += savingsConsistency * 0.35;

    return Math.min(Math.round(disciplineScore), maxScore);
  }

  private analyzePunctuality(transactions: Transaction[]): number {
    // Analyze recurring payments (bills, loans, subscriptions)
    const recurringPayments = this.identifyRecurringPayments(transactions);
    
    if (recurringPayments.length === 0) return 500; // Neutral score for no data

    let totalPunctuality = 0;
    let paymentGroups = 0;

    for (const paymentGroup of recurringPayments) {
      const onTimePayments = paymentGroup.payments.filter(p => p.days_late <= 0).length;
      const punctualityRate = onTimePayments / paymentGroup.payments.length;
      
      // Score: 1000 for 100% on-time, decreasing exponentially
      const groupScore = Math.max(0, 1000 * Math.pow(punctualityRate, 2));
      totalPunctuality += groupScore;
      paymentGroups++;
    }

    return paymentGroups > 0 ? totalPunctuality / paymentGroups : 500;
  }

  private analyzeOverdraftBehavior(transactions: Transaction[]): number {
    const overdrafts = transactions.filter(t => 
      t.amount < 0 && t.balance_after < 0
    );

    if (overdrafts.length === 0) return 1000; // Perfect score for no overdrafts

    // Calculate overdraft severity
    const totalOverdraftAmount = overdrafts.reduce((sum, t) => sum + Math.abs(t.balance_after), 0);
    const avgMonthlyIncome = this.calculateAverageMonthlyIncome(transactions);
    
    if (avgMonthlyIncome === 0) return 300; // Low score for no income data

    const overdraftRatio = totalOverdraftAmount / (avgMonthlyIncome * 12);
    
    // Score decreases exponentially with overdraft ratio
    // No overdrafts = 1000, 1% of annual income = ~800, 5% = ~400, 10%+ = 0
    return Math.max(0, Math.round(1000 * Math.exp(-overdraftRatio * 10)));
  }

  private analyzeSavingsRegularity(transactions: Transaction[]): number {
    // Group transactions by month
    const monthlyData = this.groupTransactionsByMonth(transactions);
    
    if (monthlyData.length < 3) return 400; // Need at least 3 months of data

    let savingsConsistency = 0;
    let monthsWithSavings = 0;

    for (const month of monthlyData) {
      const income = month.transactions.filter(t => t.amount > 0).reduce((sum, t) => sum + t.amount, 0);
      const expenses = month.transactions.filter(t => t.amount < 0).reduce((sum, t) => sum + Math.abs(t.amount), 0);
      
      if (income > expenses) {
        monthsWithSavings++;
      }
    }

    const savingsRate = monthsWithSavings / monthlyData.length;
    
    // Calculate consistency bonus
    const savingsAmounts = monthlyData.map(m => {
      const income = m.transactions.filter(t => t.amount > 0).reduce((sum, t) => sum + t.amount, 0);
      const expenses = m.transactions.filter(t => t.amount < 0).reduce((sum, t) => sum + Math.abs(t.amount), 0);
      return Math.max(0, income - expenses);
    });

    const avgSavings = savingsAmounts.reduce((sum, amt) => sum + amt, 0) / savingsAmounts.length;
    const savingsVariance = this.calculateVariance(savingsAmounts, avgSavings);
    const consistencyScore = avgSavings > 0 ? Math.max(0, 1 - (savingsVariance / Math.pow(avgSavings, 2))) : 0;

    return Math.round(1000 * savingsRate * (0.7 + 0.3 * consistencyScore));
  }

  private async calculateIncomeScore(data: FinancialData): Promise<number> {
    const monthlyIncomes = this.calculateMonthlyIncomes(data.transactions);
    
    if (monthlyIncomes.length < 3) return 300; // Insufficient data

    // Income stability (40% of income score)
    const stabilityScore = this.calculateIncomeStability(monthlyIncomes);
    
    // Income growth (30% of income score)
    const growthScore = this.calculateIncomeGrowth(monthlyIncomes);
    
    // Income diversification (30% of income score)
    const diversificationScore = this.calculateIncomeDiversification(data.transactions);

    const incomeScore = Math.round(
      (stabilityScore * 0.40) +
      (growthScore * 0.30) +
      (diversificationScore * 0.30)
    );

    return Math.min(incomeScore, 1000);
  }

  private calculateIncomeStability(monthlyIncomes: number[]): number {
    if (monthlyIncomes.length < 2) return 200;

    const avgIncome = monthlyIncomes.reduce((sum, income) => sum + income, 0) / monthlyIncomes.length;
    const variance = this.calculateVariance(monthlyIncomes, avgIncome);
    const coefficientOfVariation = avgIncome > 0 ? Math.sqrt(variance) / avgIncome : 1;

    // Lower coefficient of variation = higher stability score
    // CV < 0.1 = 1000, CV = 0.5 = 500, CV > 1.0 = 100
    return Math.max(100, Math.round(1000 * Math.exp(-coefficientOfVariation * 2)));
  }

  private calculateIncomeGrowth(monthlyIncomes: number[]): number {
    if (monthlyIncomes.length < 6) return 500; // Need at least 6 months for trend analysis

    // Calculate linear regression slope
    const n = monthlyIncomes.length;
    const xValues = Array.from({ length: n }, (_, i) => i + 1);
    const slope = this.calculateLinearRegression(xValues, monthlyIncomes).slope;
    
    const avgIncome = monthlyIncomes.reduce((sum, income) => sum + income, 0) / monthlyIncomes.length;
    const monthlyGrowthRate = avgIncome > 0 ? slope / avgIncome : 0;
    
    // Convert to annual growth rate
    const annualGrowthRate = monthlyGrowthRate * 12;
    
    // Score based on growth rate
    // 10%+ annual growth = 1000, 0% growth = 500, -10% decline = 0
    return Math.max(0, Math.min(1000, Math.round(500 + (annualGrowthRate * 5000))));
  }

  private calculateIncomeDiversification(transactions: Transaction[]): number {
    const incomeTransactions = transactions.filter(t => t.amount > 0);
    
    if (incomeTransactions.length === 0) return 0;

    // Group income by source (merchant/description similarity)
    const incomeSources = this.groupIncomeBySource(incomeTransactions);
    
    if (incomeSources.length === 1) return 300; // Single income source
    
    // Calculate Herfindahl-Hirschman Index for income concentration
    const totalIncome = incomeTransactions.reduce((sum, t) => sum + t.amount, 0);
    const sourceShares = incomeSources.map(source => 
      source.total_amount / totalIncome
    );
    
    const hhi = sourceShares.reduce((sum, share) => sum + Math.pow(share, 2), 0);
    
    // Convert HHI to diversification score
    // HHI = 1 (monopoly) = 300, HHI = 0.5 = 600, HHI = 0.25 = 1000
    return Math.max(300, Math.round(1000 * (1 - hhi) * 1.33));
  }

  private async calculateVelocityScore(data: FinancialData): Promise<number> {
    // Cash flow timing (50% of velocity score)
    const timingScore = this.analyzeCashFlowTiming(data.transactions);
    
    // Liquidity management (30% of velocity score)
    const liquidityScore = this.analyzeLiquidityManagement(data.transactions, data.accounts);
    
    // Payment efficiency (20% of velocity score)
    const efficiencyScore = this.analyzePaymentEfficiency(data.transactions);

    const velocityScore = Math.round(
      (timingScore * 0.50) +
      (liquidityScore * 0.30) +
      (efficiencyScore * 0.20)
    );

    return Math.min(velocityScore, 1000);
  }

  private async calculateAssetsScore(data: FinancialData): Promise<number> {
    // Savings rate (40% of assets score)
    const savingsRateScore = this.calculateSavingsRateScore(data.transactions);
    
    // Investment balance (35% of assets score) 
    const investmentScore = await this.calculateInvestmentScore(data.user_id);
    
    // Net worth growth (25% of assets score)
    const netWorthScore = this.calculateNetWorthGrowth(data.accounts, data.transactions);

    const assetsScore = Math.round(
      (savingsRateScore * 0.40) +
      (investmentScore * 0.35) +
      (netWorthScore * 0.25)
    );

    return Math.min(assetsScore, 1000);
  }

  private determinePortfolioTier(score: number): 'bronze' | 'silver' | 'gold' | 'platinum' {
    if (score >= 850) return 'platinum';
    if (score >= 650) return 'gold';
    if (score >= 400) return 'silver';
    return 'bronze';
  }

  private async generateInsights(components: DivaScoreComponents, data: FinancialData): Promise<DivaInsight[]> {
    const insights: DivaInsight[] = [];

    // Discipline insights
    if (components.discipline < 500) {
      insights.push({
        category: 'discipline',
        insight_type: 'improvement_opportunity',
        title: 'Improve Payment Consistency',
        description: 'Your payment discipline score indicates room for improvement in on-time payments.',
        recommendation: 'Set up automatic payments for recurring bills and loans to improve your discipline score.',
        impact_level: 'high',
        actionable: true,
        priority: 80
      });
    }

    // Income insights
    if (components.income < 600) {
      insights.push({
        category: 'income',
        insight_type: 'improvement_opportunity',
        title: 'Diversify Income Sources',
        description: 'Having multiple income sources can improve your financial stability.',
        recommendation: 'Consider developing additional income streams through side projects or investments.',
        impact_level: 'medium',
        actionable: true,
        priority: 60
      });
    }

    // Velocity insights
    if (components.velocity < 550) {
      insights.push({
        category: 'velocity',
        insight_type: 'improvement_opportunity',
        title: 'Optimize Cash Flow Timing',
        description: 'Your money velocity could be improved through better cash flow management.',
        recommendation: 'Align your income and expense timing to maintain better liquidity.',
        impact_level: 'medium',
        actionable: true,
        priority: 50
      });
    }

    // Assets insights
    if (components.assets < 400) {
      insights.push({
        category: 'assets',
        insight_type: 'improvement_opportunity',
        title: 'Increase Savings Rate',
        description: 'Your savings rate is below the recommended level for financial health.',
        recommendation: 'Try to save at least 20% of your income each month. Start with automated savings.',
        impact_level: 'high',
        actionable: true,
        priority: 90
      });
    }

    // Strength insights
    if (components.discipline >= 800) {
      insights.push({
        category: 'discipline',
        insight_type: 'strength',
        title: 'Excellent Payment Discipline',
        description: 'You consistently make payments on time and avoid overdrafts.',
        recommendation: 'Maintain this excellent discipline to access better investment opportunities.',
        impact_level: 'low',
        actionable: false,
        priority: 20
      });
    }

    return insights.sort((a, b) => b.priority - a.priority);
  }

  // Helper methods
  private calculateVariance(values: number[], mean: number): number {
    const squaredDiffs = values.map(value => Math.pow(value - mean, 2));
    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;
  }

  private calculateLinearRegression(x: number[], y: number[]): { slope: number; intercept: number } {
    const n = x.length;
    const sumX = x.reduce((sum, val) => sum + val, 0);
    const sumY = y.reduce((sum, val) => sum + val, 0);
    const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);
    const sumXX = x.reduce((sum, val) => sum + val * val, 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;

    return { slope, intercept };
  }

  private async saveScoreResult(result: DivaScoreResult): Promise<void> {
    await this.db.transaction(async (trx) => {
      // Archive existing active score
      await trx('diva_scores')
        .where({ user_id: result.user_id, status: 'active' })
        .update({ status: 'expired' });

      // Insert new score
      const scoreId = await trx('diva_scores').insert({
        user_id: result.user_id,
        overall_score: result.overall_score,
        discipline_score: result.components.discipline,
        income_score: result.components.income,
        velocity_score: result.components.velocity,
        assets_score: result.components.assets,
        portfolio_tier: result.portfolio_tier,
        calculation_version: result.calculation_metadata.calculation_version,
        data_period_start: result.calculation_metadata.data_period_start,
        data_period_end: result.calculation_metadata.data_period_end,
        calculated_at: new Date(),
        next_update_due: new Date(Date.now() + (90 * 24 * 60 * 60 * 1000)), // 90 days
        status: 'active'
      }).returning('id');

      // Insert insights
      if (result.insights.length > 0) {
        await trx('diva_insights').insert(
          result.insights.map(insight => ({
            user_id: result.user_id,
            diva_score_id: scoreId[0].id,
            category: insight.category,
            insight_type: insight.insight_type,
            title: insight.title,
            description: insight.description,
            recommendation: insight.recommendation,
            impact_level: insight.impact_level,
            actionable: insight.actionable,
            priority: insight.priority
          }))
        );
      }
    });
  }
}
```

### RTSM Integration

Implement Risk Tolerance Scoring Model:

```typescript
// rtsm-calculator.ts
export interface RTSMQuestion {
  id: string;
  category: 'risk_capacity' | 'risk_tolerance' | 'investment_experience' | 'time_horizon';
  question_text: string;
  question_type: 'multiple_choice' | 'scale' | 'yes_no';
  options?: { value: number; label: string }[];
  weight: number;
  required: boolean;
}

export interface RTSMResponse {
  question_id: string;
  answer: number | string;
  normalized_score: number; // 0-100
}

export interface RTSMResult {
  user_id: string;
  overall_risk_score: number; // 0-100
  risk_profile: 'conservative' | 'moderate' | 'balanced' | 'growth' | 'aggressive';
  category_scores: {
    risk_capacity: number;
    risk_tolerance: number;
    investment_experience: number;
    time_horizon: number;
  };
  recommended_allocation: {
    cash: number;
    bonds: number;
    equities: number;
    alternatives: number;
  };
  responses: RTSMResponse[];
}

export class RTSMCalculator {
  private questions: RTSMQuestion[] = [
    // Risk Capacity Questions
    {
      id: 'rc_001',
      category: 'risk_capacity',
      question_text: 'What is your current age?',
      question_type: 'multiple_choice',
      options: [
        { value: 20, label: 'Under 25' },
        { value: 40, label: '25-35' },
        { value: 60, label: '36-45' },
        { value: 80, label: '46-55' },
        { value: 100, label: 'Over 55' }
      ],
      weight: 0.25,
      required: true
    },
    {
      id: 'rc_002',
      category: 'risk_capacity',
      question_text: 'How stable is your current income?',
      question_type: 'multiple_choice',
      options: [
        { value: 100, label: 'Very stable with regular increases' },
        { value: 80, label: 'Stable with occasional fluctuations' },
        { value: 60, label: 'Somewhat variable but predictable' },
        { value: 40, label: 'Variable and unpredictable' },
        { value: 20, label: 'Very unstable or no regular income' }
      ],
      weight: 0.30,
      required: true
    },
    {
      id: 'rc_003',
      category: 'risk_capacity',
      question_text: 'How much emergency savings do you have?',
      question_type: 'multiple_choice',
      options: [
        { value: 100, label: 'More than 6 months of expenses' },
        { value: 80, label: '3-6 months of expenses' },
        { value: 60, label: '1-3 months of expenses' },
        { value: 40, label: 'Less than 1 month of expenses' },
        { value: 20, label: 'No emergency savings' }
      ],
      weight: 0.25,
      required: true
    },

    // Risk Tolerance Questions
    {
      id: 'rt_001',
      category: 'risk_tolerance',
      question_text: 'If your investment lost 20% of its value in one month, what would you do?',
      question_type: 'multiple_choice',
      options: [
        { value: 100, label: 'Buy more at the lower price' },
        { value: 80, label: 'Hold and wait for recovery' },
        { value: 60, label: 'Feel concerned but take no action' },
        { value: 40, label: 'Sell some to reduce losses' },
        { value: 20, label: 'Sell everything immediately' }
      ],
      weight: 0.35,
      required: true
    },
    {
      id: 'rt_002',
      category: 'risk_tolerance',
      question_text: 'How do you feel about investment volatility?',
      question_type: 'scale',
      options: [
        { value: 20, label: 'Very uncomfortable with any fluctuations' },
        { value: 40, label: 'Uncomfortable with large fluctuations' },
        { value: 60, label: 'Comfortable with moderate fluctuations' },
        { value: 80, label: 'Comfortable with significant fluctuations' },
        { value: 100, label: 'Very comfortable with all fluctuations' }
      ],
      weight: 0.30,
      required: true
    },

    // Investment Experience Questions
    {
      id: 'ie_001',
      category: 'investment_experience',
      question_text: 'How many years of investment experience do you have?',
      question_type: 'multiple_choice',
      options: [
        { value: 20, label: 'No investment experience' },
        { value: 40, label: 'Less than 2 years' },
        { value: 60, label: '2-5 years' },
        { value: 80, label: '5-10 years' },
        { value: 100, label: 'More than 10 years' }
      ],
      weight: 0.40,
      required: true
    },
    {
      id: 'ie_002',
      category: 'investment_experience',
      question_text: 'Which investment products have you used?',
      question_type: 'multiple_choice',
      options: [
        { value: 20, label: 'Only savings accounts' },
        { value: 40, label: 'Savings and fixed deposits' },
        { value: 60, label: 'Mutual funds and ETFs' },
        { value: 80, label: 'Individual stocks and bonds' },
        { value: 100, label: 'Complex derivatives and alternatives' }
      ],
      weight: 0.35,
      required: true
    },

    // Time Horizon Questions
    {
      id: 'th_001',
      category: 'time_horizon',
      question_text: 'When do you expect to need this money?',
      question_type: 'multiple_choice',
      options: [
        { value: 20, label: 'Within 1 year' },
        { value: 40, label: '1-3 years' },
        { value: 60, label: '3-7 years' },
        { value: 80, label: '7-15 years' },
        { value: 100, label: 'More than 15 years' }
      ],
      weight: 0.50,
      required: true
    }
  ];

  async calculateRTSMScore(userId: string, responses: Array<{ question_id: string; answer: number }>): Promise<RTSMResult> {
    // Validate responses
    const normalizedResponses = this.normalizeResponses(responses);

    // Calculate category scores
    const categoryScores = this.calculateCategoryScores(normalizedResponses);

    // Calculate overall risk score
    const overallRiskScore = this.calculateOverallScore(categoryScores);

    // Determine risk profile
    const riskProfile = this.determineRiskProfile(overallRiskScore);

    // Generate recommended allocation
    const recommendedAllocation = this.generateAllocation(riskProfile, categoryScores);

    const result: RTSMResult = {
      user_id: userId,
      overall_risk_score: overallRiskScore,
      risk_profile: riskProfile,
      category_scores: categoryScores,
      recommended_allocation: recommendedAllocation,
      responses: normalizedResponses
    };

    // Save to database
    await this.saveRTSMResult(result);

    return result;
  }

  private normalizeResponses(responses: Array<{ question_id: string; answer: number }>): RTSMResponse[] {
    return responses.map(response => {
      const question = this.questions.find(q => q.id === response.question_id);
      if (!question) {
        throw new Error(`Question not found: ${response.question_id}`);
      }

      return {
        question_id: response.question_id,
        answer: response.answer,
        normalized_score: response.answer // Already normalized to 0-100 in question options
      };
    });
  }

  private calculateCategoryScores(responses: RTSMResponse[]): {
    risk_capacity: number;
    risk_tolerance: number;
    investment_experience: number;
    time_horizon: number;
  } {
    const categories = ['risk_capacity', 'risk_tolerance', 'investment_experience', 'time_horizon'] as const;
    const scores: any = {};

    for (const category of categories) {
      const categoryQuestions = this.questions.filter(q => q.category === category);
      const categoryResponses = responses.filter(r => 
        categoryQuestions.some(q => q.id === r.question_id)
      );

      let weightedSum = 0;
      let totalWeight = 0;

      for (const response of categoryResponses) {
        const question = categoryQuestions.find(q => q.id === response.question_id)!;
        weightedSum += response.normalized_score * question.weight;
        totalWeight += question.weight;
      }

      scores[category] = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 50;
    }

    return scores;
  }

  private calculateOverallScore(categoryScores: {
    risk_capacity: number;
    risk_tolerance: number;
    investment_experience: number;
    time_horizon: number;
  }): number {
    // Weighted average of category scores
    const weights = {
      risk_capacity: 0.25,
      risk_tolerance: 0.35,
      investment_experience: 0.20,
      time_horizon: 0.20
    };

    const weightedScore = (
      categoryScores.risk_capacity * weights.risk_capacity +
      categoryScores.risk_tolerance * weights.risk_tolerance +
      categoryScores.investment_experience * weights.investment_experience +
      categoryScores.time_horizon * weights.time_horizon
    );

    return Math.round(weightedScore);
  }

  private determineRiskProfile(score: number): 'conservative' | 'moderate' | 'balanced' | 'growth' | 'aggressive' {
    if (score >= 80) return 'aggressive';
    if (score >= 65) return 'growth';
    if (score >= 50) return 'balanced';
    if (score >= 35) return 'moderate';
    return 'conservative';
  }

  private generateAllocation(riskProfile: string, categoryScores: any): {
    cash: number;
    bonds: number;
    equities: number;
    alternatives: number;
  } {
    const baseAllocations: Record<string, any> = {
      conservative: { cash: 30, bonds: 50, equities: 20, alternatives: 0 },
      moderate: { cash: 20, bonds: 40, equities: 35, alternatives: 5 },
      balanced: { cash: 15, bonds: 35, equities: 45, alternatives: 5 },
      growth: { cash: 10, bonds: 25, equities: 60, alternatives: 5 },
      aggressive: { cash: 5, bonds: 15, equities: 70, alternatives: 10 }
    };

    let allocation = { ...baseAllocations[riskProfile] };

    // Adjust based on specific factors
    if (categoryScores.time_horizon < 40) {
      // Short time horizon - increase cash/bonds
      allocation.cash += 10;
      allocation.bonds += 5;
      allocation.equities -= 15;
    }

    if (categoryScores.investment_experience < 40) {
      // Low experience - reduce alternatives
      allocation.alternatives = Math.min(allocation.alternatives, 2);
      allocation.bonds += allocation.alternatives - 2;
    }

    // Ensure allocation sums to 100%
    const total = Object.values(allocation).reduce((sum: number, val: number) => sum + val, 0);
    if (total !== 100) {
      const adjustment = (100 - total) / 4;
      allocation.cash += adjustment;
      allocation.bonds += adjustment;
      allocation.equities += adjustment;
      allocation.alternatives += adjustment;
    }

    // Round to integers
    return {
      cash: Math.round(allocation.cash),
      bonds: Math.round(allocation.bonds),
      equities: Math.round(allocation.equities),
      alternatives: Math.round(allocation.alternatives)
    };
  }

  private async saveRTSMResult(result: RTSMResult): Promise<void> {
    await this.db.query(`
      INSERT INTO rtsm_assessments (
        user_id, overall_risk_score, risk_profile, 
        risk_capacity_score, risk_tolerance_score, 
        investment_experience_score, time_horizon_score,
        recommended_allocation, responses, completed_at, expires_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
      )
      ON CONFLICT (user_id) 
      DO UPDATE SET
        overall_risk_score = EXCLUDED.overall_risk_score,
        risk_profile = EXCLUDED.risk_profile,
        risk_capacity_score = EXCLUDED.risk_capacity_score,
        risk_tolerance_score = EXCLUDED.risk_tolerance_score,
        investment_experience_score = EXCLUDED.investment_experience_score,
        time_horizon_score = EXCLUDED.time_horizon_score,
        recommended_allocation = EXCLUDED.recommended_allocation,
        responses = EXCLUDED.responses,
        completed_at = EXCLUDED.completed_at,
        expires_at = EXCLUDED.expires_at,
        status = 'active'
    `, [
      result.user_id,
      result.overall_risk_score,
      result.risk_profile,
      result.category_scores.risk_capacity,
      result.category_scores.risk_tolerance,
      result.category_scores.investment_experience,
      result.category_scores.time_horizon,
      JSON.stringify(result.recommended_allocation),
      JSON.stringify(result.responses),
      new Date(),
      new Date(Date.now() + (365 * 24 * 60 * 60 * 1000)) // 1 year expiry
    ]);
  }
}
```

### API Endpoints

Create comprehensive API endpoints for DIVA score management:

```typescript
// diva-routes.ts
import { Router } from 'express';
import { DivaCalculator } from './diva-calculator';
import { RTSMCalculator } from './rtsm-calculator';
import { authMiddleware, validateInput } from './middleware';

const router = Router();

// Get current DIVA score
router.get('/users/:userId/diva-score', authMiddleware, async (req, res) => {
  try {
    const { userId } = req.params;
    
    const score = await divaService.getCurrentScore(userId);
    if (!score) {
      return res.status(404).json({ error: 'No DIVA score found. Please link a bank account first.' });
    }

    res.json({
      success: true,
      data: score
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Trigger DIVA score refresh
router.post('/users/:userId/diva-score/refresh', authMiddleware, async (req, res) => {
  try {
    const { userId } = req.params;
    const { force_recalculation = false } = req.body;

    // Check if user has sufficient data
    const hasData = await bankingService.hasTransactionData(userId);
    if (!hasData) {
      return res.status(400).json({ 
        error: 'Insufficient transaction data. Please link a bank account and wait for data synchronization.' 
      });
    }

    // Queue calculation job
    const calculationJob = await divaCalculator.calculateDivaScore({
      user_id: userId,
      analysis_period_months: 12,
      force_recalculation
    });

    res.json({
      success: true,
      data: {
        calculation_id: calculationJob.id,
        estimated_completion: calculationJob.estimated_completion,
        status: 'processing'
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get DIVA score history
router.get('/users/:userId/diva-score/history', authMiddleware, async (req, res) => {
  try {
    const { userId } = req.params;
    const { months = 12 } = req.query;

    const history = await divaService.getScoreHistory(userId, parseInt(months as string));

    res.json({
      success: true,
      data: {
        history,
        trend_analysis: divaService.analyzeTrend(history)
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get RTSM assessment questions
router.get('/users/:userId/rtsm/questions', authMiddleware, async (req, res) => {
  try {
    const questions = await rtsmCalculator.getQuestions();
    
    res.json({
      success: true,
      data: { questions }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Submit RTSM assessment
router.post('/users/:userId/rtsm/assessment', authMiddleware, validateInput, async (req, res) => {
  try {
    const { userId } = req.params;
    const { responses } = req.body;

    const result = await rtsmCalculator.calculateRTSMScore(userId, responses);

    // Trigger portfolio tier recalculation
    await portfolioService.updateUserTier(userId, result);

    res.json({
      success: true,
      data: result
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get combined portfolio recommendation
router.get('/users/:userId/portfolio-recommendation', authMiddleware, async (req, res) => {
  try {
    const { userId } = req.params;

    const divaScore = await divaService.getCurrentScore(userId);
    const rtsmAssessment = await rtsmService.getCurrentAssessment(userId);

    if (!divaScore || !rtsmAssessment) {
      return res.status(400).json({
        error: 'Complete DIVA assessment and RTSM questionnaire required for portfolio recommendation'
      });
    }

    const recommendation = await portfolioService.generateRecommendation({
      diva_score: divaScore,
      rtsm_assessment: rtsmAssessment,
      user_preferences: await userService.getInvestmentPreferences(userId)
    });

    res.json({
      success: true,
      data: recommendation
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

export default router;
```

## Testing DIVA Implementation

### Unit Tests

```typescript
// diva-calculator.test.ts
import { DivaCalculator } from '../src/diva-calculator';
import { mockTransactionData, mockAccountData } from './fixtures';

describe('DivaCalculator', () => {
  let calculator: DivaCalculator;

  beforeEach(() => {
    calculator = new DivaCalculator(mockDb, mockBankingService);
  });

  describe('Discipline Score Calculation', () => {
    test('should calculate perfect discipline score for consistent payments', async () => {
      const transactions = mockTransactionData.consistentPayments;
      const score = await calculator.calculateDisciplineScore({ transactions });
      
      expect(score).toBeGreaterThan(900);
    });

    test('should penalize overdraft behavior', async () => {
      const transactions = mockTransactionData.withOverdrafts;
      const score = await calculator.calculateDisciplineScore({ transactions });
      
      expect(score).toBeLessThan(600);
    });

    test('should reward regular savings', async () => {
      const transactions = mockTransactionData.regularSavers;
      const score = await calculator.calculateDisciplineScore({ transactions });
      
      expect(score).toBeGreaterThan(700);
    });
  });

  describe('Income Score Calculation', () => {
    test('should score stable income highly', async () => {
      const transactions = mockTransactionData.stableIncome;
      const score = await calculator.calculateIncomeScore({ transactions });
      
      expect(score).toBeGreaterThan(800);
    });

    test('should reward income diversification', async () => {
      const transactions = mockTransactionData.diversifiedIncome;
      const score = await calculator.calculateIncomeScore({ transactions });
      
      expect(score).toBeGreaterThan(700);
    });

    test('should penalize irregular income', async () => {
      const transactions = mockTransactionData.irregularIncome;
      const score = await calculator.calculateIncomeScore({ transactions });
      
      expect(score).toBeLessThan(500);
    });
  });

  describe('Portfolio Tier Assignment', () => {
    test('should assign correct tiers based on score ranges', () => {
      expect(calculator.determinePortfolioTier(950)).toBe('platinum');
      expect(calculator.determinePortfolioTier(750)).toBe('gold');
      expect(calculator.determinePortfolioTier(550)).toBe('silver');
      expect(calculator.determinePortfolioTier(350)).toBe('bronze');
    });
  });

  describe('Insights Generation', () => {
    test('should generate actionable insights for low scores', async () => {
      const components = {
        discipline: 300,
        income: 400,
        velocity: 350,
        assets: 200
      };

      const insights = await calculator.generateInsights(components, mockTransactionData.lowPerformer);
      
      expect(insights.length).toBeGreaterThan(2);
      expect(insights.some(i => i.actionable)).toBe(true);
      expect(insights.some(i => i.impact_level === 'high')).toBe(true);
    });
  });
});
```

### Integration Tests

```typescript
// diva-integration.test.ts
describe('DIVA Integration Tests', () => {
  test('should complete full DIVA calculation flow', async () => {
    // Create test user
    const user = await testDb.createUser({
      email: 'test@example.com',
      country_code: 'ZA'
    });

    // Link test bank account with transactions
    await testDb.linkBankAccount(user.id, {
      account_id: 'test_account',
      transactions: mockTransactionData.typicalUser
    });

    // Calculate DIVA score
    const result = await divaCalculator.calculateDivaScore({
      user_id: user.id,
      analysis_period_months: 12
    });

    // Verify results
    expect(result.overall_score).toBeGreaterThan(0);
    expect(result.overall_score).toBeLessThanOrEqual(1000);
    expect(result.portfolio_tier).toMatch(/bronze|silver|gold|platinum/);
    expect(result.components.discipline).toBeDefined();
    expect(result.components.income).toBeDefined();
    expect(result.components.velocity).toBeDefined();
    expect(result.components.assets).toBeDefined();

    // Verify database storage
    const savedScore = await testDb.getDivaScore(user.id);
    expect(savedScore.overall_score).toBe(result.overall_score);
    expect(savedScore.status).toBe('active');
  });

  test('should integrate DIVA with RTSM for portfolio assignment', async () => {
    const user = await testDb.createUser();
    
    // Calculate DIVA score
    const divaResult = await divaCalculator.calculateDivaScore({
      user_id: user.id,
      analysis_period_months: 12
    });

    // Complete RTSM assessment
    const rtsmResult = await rtsmCalculator.calculateRTSMScore(user.id, [
      { question_id: 'rc_001', answer: 60 }, // Age 36-45
      { question_id: 'rc_002', answer: 80 }, // Stable income
      { question_id: 'rt_001', answer: 80 }, // Risk tolerant
      // ... more responses
    ]);

    // Verify combined portfolio assignment
    const recommendation = await portfolioService.generateRecommendation({
      diva_score: divaResult,
      rtsm_assessment: rtsmResult
    });

    expect(recommendation.recommended_tier).toBeDefined();
    expect(recommendation.asset_allocation).toBeDefined();
    expect(recommendation.investment_limits).toBeDefined();
  });
});
```

## Monitoring and Optimization

### Performance Monitoring

Set up monitoring for DIVA score calculations:

```typescript
// diva-monitoring.ts
export class DivaMonitoring {
  async trackCalculationPerformance(userId: string, calculation: () => Promise<DivaScoreResult>): Promise<DivaScoreResult> {
    const startTime = Date.now();
    
    try {
      const result = await calculation();
      
      // Track successful calculation
      await this.recordMetric('diva_calculation_success', {
        user_id: userId,
        calculation_time: Date.now() - startTime,
        score: result.overall_score,
        tier: result.portfolio_tier,
        insights_count: result.insights.length
      });

      return result;
    } catch (error) {
      // Track calculation errors
      await this.recordMetric('diva_calculation_error', {
        user_id: userId,
        error_type: error.constructor.name,
        error_message: error.message,
        calculation_time: Date.now() - startTime
      });

      throw error;
    }
  }

  async generateCalculationReport(): Promise<{
    total_calculations: number;
    average_calculation_time: number;
    success_rate: number;
    tier_distribution: Record<string, number>;
    common_errors: Array<{ error: string; count: number }>;
  }> {
    // Implementation for generating calculation performance reports
    return this.queryMetrics('diva_calculations', {
      period: '30d',
      aggregations: ['count', 'avg_time', 'success_rate', 'tier_distribution']
    });
  }
}
```

### Optimization Strategies

<CardGroup cols={2}>
  <Card title="Database Optimization" icon="database">
    **Indexing**: Optimize queries with proper indexes  
    **Materialized Views**: Pre-calculate common aggregations  
    **Partitioning**: Partition large transaction tables by date  
    **Query Optimization**: Use EXPLAIN ANALYZE for slow queries
  </Card>
  <Card title="Calculation Optimization" icon="calculator">
    **Caching**: Cache intermediate calculations  
    **Batch Processing**: Process multiple users efficiently  
    **Incremental Updates**: Update scores based on new data only  
    **Parallel Processing**: Parallelize component calculations
  </Card>
</CardGroup>

## Troubleshooting Common Issues

### Data Quality Issues

| Issue | Symptoms | Solution |
|-------|----------|----------|
| Insufficient Transaction Data | Low confidence scores, default values | Require minimum 3 months of data |
| Irregular Income Patterns | Volatile income scores | Implement income smoothing algorithms |
| Duplicate Transactions | Inflated scores | Add transaction deduplication logic |
| Missing Transaction Categories | Incorrect velocity calculations | Enhance transaction categorization |

### Calculation Errors

<Steps>
  <Step title="Validate Input Data">
    Ensure all required transaction and account data is present and properly formatted
  </Step>
  <Step title="Check Business Logic">
    Verify that component calculations follow documented business rules
  </Step>
  <Step title="Review Thresholds">
    Confirm that scoring thresholds align with business requirements
  </Step>
  <Step title="Test Edge Cases">
    Handle users with extreme financial patterns appropriately
  </Step>
</Steps>

---

*This DIVA Score Implementation Guide provides the foundation for building a sophisticated financial health scoring system tailored to African markets. The rule-based approach ensures transparency and regulatory compliance while providing actionable insights for users.*

*For additional support, refer to the [Testing Strategies](/guides/testing-strategies) and [Best Practices](/guides/best-practices) guides.*